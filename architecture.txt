// Использование Монолитная компонентно-ориентированная архитектуры (сначала юзаем ее)
Общая структура: 
/src
├── components/          # Многоразовые UI-компоненты (кнопки, карточки, инпуты)
├── layouts/             # Макеты страниц (Header, Sidebar, Footer, MainLayout)
├── pages/               # Страницы приложения (Home, Profile, Settings)
├── services/            # Логика работы с API, внешними сервисами
├── store/               # Управление глобальным состоянием (Redux, Zustand, Pinia)
├── utils/               # Вспомогательные функции (форматирование даты, валидация)
├── assets/              # Изображения, шрифты, стили
└── App.jsx              # Точка входа приложения

Ключевые принципы организации:
Разделение ответственности (Separation of Concerns): Каждая папка имеет четкую цель. Компоненты занимаются только UI, сервисы — только данными.
Инкапсуляция: Компоненты скрывают свою внутреннюю логику и стили от внешнего мира.

Иерархия компонентов (матрешка)
graph TD
    A[App - Корневой компонент] --> B(Main Layout);
    B --> C(Header);
    B --> D(Sidebar);
    B --> E(Main Content);
    E --> F(Widget 1);
    E --> G(Widget 2);
    F --> H(Button);
    F --> I(List Item);

Типы компонентов:
1. UI (только внешний вид. Получает данные и колбекит через пропсы - Button, Card, Modal)
2. Logic (только логика. Отвечает за получение данных, управление состоянием, передачу данных UI компонентам - UserProfileContainer, ProductListFetcher)

3. Потоки данных и управление состоянияем
В монолитной архитектуре все компоненты находятся в одном адресном пространстве, что упрощает управление данными.
Локальное состояние: Используется внутри одного компонента (например, открыт ли модальное окно).
Глобальное состояние (Store): Используется для данных, которые нужны многим частям приложения (данные пользователя, корзина покупок, настройки темы). В монолите обычно используется единый менеджер состояния (Redux, Context API, Zustand).
Поток данных: Обычно однонаправленный (как в React): данные "текут" сверху вниз от родительских компонентов к дочерним через пропсы, а события (клики) "поднимаются" снизу вверх через колбэки.

------------------------------------

// Когда проект разрастается подгоняем под Шаблон модульной структуры или FSD
1. Обычная модульная структура:
/src
├── modules/                 # Основная модульная структура
│   ├── UserProfile/         # Модуль "Профиль пользователя"
│   │   ├── components/      # Компоненты внутри модуля (Avatar, ProfileForm)
│   │   ├── api/             # API запросы, связанные с профилем
│   │   ├── store/           # Локальное состояние профиля (опционально)
│   │   ├── UserProfile.jsx  # Основной компонент/точка входа модуля
│   │   └── style.css        # Стили модуля
│   ├── Products/            # Модуль "Товары"
│   │   ├── components/
│   │   ├── api/
│   │   ├── ProductsList.jsx
│   │   └── ...
│   └── Cart/                # Модуль "Корзина"
│       └── ...
├── components/              # Глобальные, переиспользуемые UI-компоненты
│   ├── Button/
│   ├── Modal/
│   └── Input/
├── utils/                   # Общие утилиты (форматирование даты, валидация)
├── services/                # Общие сервисы (глобальный API-клиент, логирование)
├── App.jsx                  # Точка входа приложения
└── index.js                 # Инициализация приложения



2. FSD архитектура
1. Основа FSD: Слои (Layers)
Весь код приложения делится на слои. Слои расположены строго вертикально, и каждый слой может использовать функциональность только тех слоев, что находятся ниже него.
graph TD
    App(App: Инициализация) --> Pages(Pages: Страницы);
    Pages --> Features(Features: Функционал);
    Features --> Entities(Entities: Сущности);
    Entities --> Shared(Shared: Общие утилиты);

2. Детализация Слоев и Папок
/src
├── app/               # 1. Слой приложения (глобальная инициализация, провайдеры)
├── pages/             # 2. Слой страниц (маршрутизация, макеты страниц)
├── features/          # 3. Слой функционала (логин, поиск, добавление в корзину)
├── entities/          # 4. Слой сущностей (продукт, пользователь, заказ)
├── shared/            # 5. Слой общих утилит (UI-кит, API-клиент, хелперы)
└── index.tsx          # Точка входа

3.  "Слайсы" внутри Слоев
Каждый слой, кроме app и pages, делится на "слайсы" (slices) по предметной области.
/src
├── entities/
│   ├── article/       # Слайс "Статья"
│   │   ├── ui/        # UI-компоненты для статьи (ArticleCard, ArticleDetails)
│   │   ├── model/     # Логика и состояние статьи (store, types)
│   │   └── api/       # API запросы для статьи (fetchArticleById)
│   ├── user/          # Слайс "Пользователь"
│   │   ├── ui/
│   │   ├── model/
│   │   └── api/
│   └── comment/       # Слайс "Комментарий"
│       └── ...

4. Жесткие Правила (Правила FSD)
Главное отличие FSD от обычной модульной структуры — это строгие правила импорта и взаимодействия:
Правило вертикальных зависимостей: Слой features может импортировать код из entities или shared, но entities никогда не может импортировать из features.
Правило приватности: Все, что находится внутри папки ui/ слайса article/, не может использоваться напрямую в другом слайсе (user/), если это не вынесено в общий shared/ui.
Четкое разделение: Внутри каждого слайса есть папки ui (только внешний вид), model (только логика), api (только запросы).


